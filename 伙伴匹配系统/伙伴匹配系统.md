# 伙伴匹配系统



## 1 需求分析

1. 用户添加**标签**，标签的分类（要哪些标签，怎么把标签进行分类） 

   例如：学习Java / c++  工作 / 大学

2. 主动搜索：允许用户根据标签去搜素其他用户
   1. redis缓存
3. 组队：
   1. 创建队伍
   2. 加入队伍
   3. 根据标签查询队伍
   4. 邀请其他人

4. 允许用户去修改标签
5. 推荐
   1. 相似度计算算法 + 本地分布式



## 2 技术栈

### 2.1 前端

1. vue3 开发框架（提高页面开发的效率）
2. vant UI （基于Vue的移动端组件库）
3. Vite（打包工具）
4. Nginx单机部署

### 2.2 后端

1. Java + springboot框架
2. springmvc + mybatis + mp
3. mysql数据库
4. redis缓存
5. swagger + Knife4j接口文档



## 3 前端设计

### 3.1 整体页面设计

1. 导航条：展示当前页面名称

2. 主页搜索框 <=> 搜索页 =>搜索结果页

3. 内容

4. tab栏：

   - 主页（推荐页 + **广告**）
   	
   - 队伍页
   	
   - 用户页
   
   
   
### 3.2 页面跳转时检查登录

1. 在全局axios配置响应拦截器，如果收到未登录的响应，就重定向到登录页
2. myAxios里写：

```js
if(response?.data.code === 40100){
        // 跳转之前的页面url
        const redirectURL = window.location.href;
        //跳转到登录页面
        window.location.href = `/user/login/?redirectURL=${redirectURL}`
    }
```

3. 登录页面写：

```js
if(response.code === 0){
    showSuccessToast("登录成功")
    window.location.href = route?.query.redirectURL ?? '/'
  }
```



   


## 4 后端设计

   ### 4.1 库表设计

   #### 4.1.1 标签表

   1. 标签分类：
   
      - 性别：男 | 女
      
      - 编程语言： c++ | java
      
      - 目标： 考研 | 求职 | 考公
      
      - 段位： 初级 | 中级 | 高级
      
      - 身份：大一 | 大二 | 大三 | 大四 | 待业 | 已就业
      
      - 状态： 乐观 | 丧 | 正常 
      
      - **【用户自定义标签】**
   2. 字段：
      - id
      - 标签名 唯一 非空 
      - 上传标签的用户
      - 父标签id
      - 是否为父标签
      - 创建时间
      - 更新时间
      - 是否删除 tinyint

   #### 4.1.2 用户表

   ...

   标签列表

   ### 4.2 后端整合 Swagger 和 Knife4j 接口文档

   1. 接口文档： 存放接口信息的文档，每条接口包括：
      - 请求参数
      - 相应参数
      - 接口地址
      - 接口名称
      - 请求类型
      - 请求格式
   2. 接口文档的作用
      - 有了书面交流的材料，便于大家进行参考和查阅，便于沉淀和维护
      - 接口文档便于前端和后端进行对接
      - 好的接口文档支持在线调试和在线测试
   3. Swagger：一个可以自动生成接口文档的工具
   4. knife4j：对 Swagger 做增强

### 4.3 爬虫

#### 4.3.1 使用EasyExcel读取表格数据

两种方式： 监听器读取 | 同步读取



### 4.4 Session共享

1. 场景：有多台服务器的情况下，判断用户是否登录，需要多台服务器共享session。
2. 实现方法：
   - 下载redis，更改redis的配置使得数据库能够远程访问
   - 引入两个依赖，`spring-boot-starter-data-redis` 和 `spring-session-data-redis`
   - 修改yml配置文件，配置redis数据的连接和session存储策略



### 4.5 缓存

1. 问题：查询数据库的速度很慢，主页要 2s 才能加载

2. 解决方法：预加载缓存，使用定时任务，定时更新缓存

3. 分布式锁：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行。

4. 缓存的实现：
    - **Redis**
    - memcached
    - ehcache（单机）
    - 本地缓存（Java内存Map）
    - **Caffeine**（Java内存缓存，高性能）

5. redis： 一个 key - value 存储系统

6. Java 操纵 Redis

   - Spring Data Redis ✔
   - Jedis
   - Redisson

7. Redis 有五种数据结构：string, list, set, map, zmap，最常用的是string

8. 设计缓存key
   - 一般命名：`systemId:moduleId:function:具体id名`
   - 例如：`yupao:user:recommend:userId`
   - **redis 的 key 要设置过期时间**，最好自己设置以下 redis 的淘汰策略

9. 缓存预热

    		- 定时触发
		
    																					- 模拟触发

10. 定时任务的实现

    1. Spring Scheduler （Spring boot 默认整合）✔
    2. Quartz（独立于Spring存在的定时任务框架）
    3. xxl-job这样的分布式任务调度系统


### 4.6 分布式锁

#### 4.6.1 场景

多台服务器同时执行定时任务，同时对 redis 进行插入操作，造成资源浪费

#### 4.6.2 解决方法

1. 分离定时任务程序和主程序，只有一个服务器执行定时任务
2. 写死配置，每个服务都可以执行定时任务，但只有ip符合配置的服务器才能真正执行
3. 动态配置，原理和 2 相同
4. 分布式锁 ✔

#### 4.6.3 分布式锁实现的关键

1. **抢锁机制**：如何保证同一时间只有一台服务器能抢到锁
2. 实现方式：
   - MySQL数据库：select for update
   - Redis实现：使用 `setnx`，不存在才能创建值
   - ZooKeeper
3. 加分布式锁的注意事项：
   - 加完锁后要释放
   - 锁要设置过期时间
   - 如果方法执行时间过长，锁提前过期了，需要续期

#### 4.6.4 redisson 实现分布式锁

1. 介绍：redisson是一个 java 操作 redis 的客户端， 能够像操作本地集合一样使用redis，且使用过程感知不到 redis 的存在

### 4.7 组队功能

1. 队伍表字段：id,name,description,maxNum,expireTime,userId, status, password...
2. 用户-队伍表
   - id主键
   - userId
   - teamId
   - joinTime
   - 三件套

### 4.8 数据校验

1. 增加队伍校验：
   - 队伍姓名不能为空
   - 最大人数不能超过10人
   - 队伍过期时间不能比今天早
   - 队伍类型不能超范围， 如果是加密队伍必须有密码

### 4.9 查询队伍列表

1. 只有管理员才能查看非公开的房间

2. 根据传入的 dto 进行条件查询

3. 可以通过输入的关键词进行查询

4. 如果队伍过期就不展示

5. 同时返回队伍创建人的信息

### 4.10 用户加入队伍

1. 只能加入未满、未过期的队伍
2. **不能重复加入已加入的队伍**
3. 如果加入的是加密队伍，需要密码
4. 每个用户最多加入5个队伍
5. 修改队伍信息，补充人数



### 4.11 退出队伍

请求参数：队伍id

1. 校验参数
2. 校验队伍是否存在
3. 校验是否加入队伍
4. 只有非队长才能退出队伍

### 4.12 解散队伍

请求参数：队伍id

1. 校验参数
2. 校验队伍是否存在
3. 校验是否加入队伍
4. 只有队长或者管理员才能解散队伍



### 4.13 推荐用户算法

1. 把每一个标签看作一个字符，使用**编辑距离**算法
2. 算法速度很慢的原因
   - 日志打印花费大量时间，取消日志快了 20s
   - 用户太多
3. 优化方法：
   - 维护一个最小堆作为最终结果，而不是全部查出来再排序
   - 查询数据库只查部分数据

### 4.14 大数据推荐流程
检索 =》 召回 =》粗排 =》 精排 =》 重排序



### 4.15 高并发的加锁问题

1. 场景：当一个用户快速点击加入队伍时，可能会使用户重复加入一个队伍。
2. 解决方法：
   - 本地锁：sychronized()语句
   - 分布式锁：用 Redisson 实现

## 5 免备案上线

1. 前端用 vercel 托管 （国外网站， 免费）
2. 后端用微信云托管（付费）



## 6 项目bug

1. 用户描述过长就无法展示
2. 用户注册的时候只会显示一次密码

## 

## 7 帖子功能实现

### 7.1 评论功能

1. 评论的种类：评论、回复
2. 查询时一级评论按时间降序排序，二级评论按时间升序排序
3. 评论表字段：id, postId, content, userId, hot, ...
4. 回复表字段：id, commentId, userId, content, hot, type, toAnswerId,  ... 

​	





