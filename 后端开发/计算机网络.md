# 计算机网络

## time_wait 状态

在四报文挥手中，主动断开连接的一方在发送最后一次的确认报文后，不会立即进入 closed 状态，而是会进入 time_wait 状态。等待大约 2MSL（Maximum Segment Lifetime）后变为 closed 状态。

**原因：**

1. 主动断开连接的一方的确认信号可能会丢失，被动断开连接的一方在长时间没有收到确认信号后，会重新发送 FIN 报文，这时候如果主动断开连接的一方处在 time_wait 状态就可以**重传确认报文**。
2. TCP 连接断开后，可能还会有一些失效的或超时的报文仍在网络中传输，如果立即使用相同的 ip 和端口建立新的连接，可能会受到这些旧报文的影响。time_wait 状态可以**保证这些旧报文都超时失效后再建立新的连接**，避免数据混乱。

## 状态码

Http 状态码由三位数字组成，第一个数字代表状态的类别。

### 1xx

表示**提示信息**，协议处理的中间状态，还有后序操作。

**例如：**

- 100：Continue。服务端已收到请求的初步数据，客户端应继续请求，
- 101：切换协议。服务器同意切换协议，例如从 Http 切换到 WebSocket。

### 2xx

表示**请求成功**。

**例如：**

- **200：OK**。服务器正确返回数据。
- 201。Created：服务器正确响应并创建了资源，常用于 post 请求。
- 204。No Content。正常响应但无内容，常用于删除。

### 3xx

表示**请求重定向**。

**例如：**

- **301：Moved Parmanently**。永久重定向，客户端应向新的 URL 发送请求。
- 302：Found：临时重定向，客户端应向原来的 URL 发送请求。
- 304：No Modified。资源未修改，客户端可以使用缓存数据。

### 4xx

表示**客户端的错误**。

**例如：**

- **400：Bad Request**。请求无效或者语法错误，服务端无法处理。
- **401：Unauthoried**。未授权，请求需要身份验证，但是客户端没有提供凭证。
- **403：Forbidden**。服务端理解请求但拒绝执行，通常是权限问题。
- 404：请求资源不存在

### 5xx

表示**服务器的错误**。

**例如：**

- **500：Internal Server Error**。服务器内部错误
- **502：Bad Gateway**。服务器作为网关或者代理服务器，无法从上游服务器收到有效响应。
- **503：Service Unavailable**：服务器暂时无法处理请求，通常是因为过载。

## HTTP 请求

HTTP 请求一般由四部分组成：请求行、请求头、空行（用于区分请求头和请求体）和请求体

### 请求行

包含 HTTP 版本、请求方式和请求资源路径

### 请求头

以键值对的形式填充数据。用于传送客户端环境、请求内容和认证信息等

### 请求体

只有在 POST、PUT 请求存在，存放客户端发送给服务端的数据。

### 常见的请求体

1. `application/x-www-form-urlencoded`：提交**表单数据**
2. `multipart/form-data`：用于**上传文件**或提交包含文件数据的表单。当请求体中包含文件时，表单的每一部分会被分隔开，且每一部分都有自己的 Content-Type。

3. `application/json`：用于发送 JSON 格式的数据。JSON 是一种**轻量级**的数据交换格式，常用于 API 请求和响应。它通常用于向服务器发送对象、数组等数据结构。
4. `application/xml`
5. `text/plain`

## HTTP 版本的变迁

| 特性/版本           | HTTP 1.0                            | HTTP 1.1                                       | HTTP 2.0                                         |
| ------------------- | ----------------------------------- | ---------------------------------------------- | ------------------------------------------------ |
| **连接复用**        | 不支持（每个请求都需要新建连接）    | 支持（使用持久连接，连接可以复用）             | 支持（使用二进制流，多个请求可以复用一个连接）   |
| **请求/响应头压缩** | 不支持                              | 不支持                                         | 支持（通过 HPACK 压缩）                          |
| **管道化**          | 不支持                              | 支持（但是有队头阻塞问题）                     | 支持（解决了队头阻塞问题）                       |
| **请求和响应顺序**  | 严格按顺序传输                      | 严格按顺序传输                                 | 不严格按顺序传输（流控制机制）                   |
| **多路复用**        | 不支持                              | 不支持                                         | 支持（多个请求/响应并行传输）                    |
| **请求方法**        | 支持 GET, POST 等常见方法           | 增加了 PUT, DELETE, PATCH 等方法               | 与 HTTP 1.1 相同                                 |
| **缓存机制**        | 支持基本的缓存机制                  | 支持更强大的缓存机制（如缓存控制，条件请求等） | 与 HTTP 1.1 相同                                 |
| **连接管理**        | 每个请求都需要一个新连接            | 持久连接，减少了连接的建立和关闭次数           | 复用连接，减少了连接的建立和关闭次数             |
| **性能**            | 较低（每个请求一个连接，没有优化）  | 较好（通过持久连接和管道化减少延迟）           | 更好（通过多路复用、二进制传输、头部压缩等优化） |
| **头部字段格式**    | 文本格式                            | 文本格式                                       | 二进制格式                                       |
| **安全性**          | 没有强制要求（通常通过 HTTPS 实现） | 没有强制要求（通常通过 HTTPS 实现）            | 强制要求加密（通过 TLS/SSL）                     |
| **支持的流量控制**  | 不支持                              | 不支持                                         | 支持（通过流量控制机制）                         |
| **延迟优化**        | 较高（需要多次建立和关闭连接）      | 较低（持久连接减少了延迟）                     | 更低（通过多路复用、流控制等机制）               |

### 总结：

- **HTTP 1.0**：每个请求都需要**单独建立连接**，性能较差。
- **HTTP 1.1**：通过**持久连接和管道化**提升性能，但依然存在**队头阻塞**问题。
- **HTTP 2.0**：通过**二进制传输、多路复用、头部压缩**等技术大大提升性能，并解决了 HTTP 1.1 的一些问题。

（PS：目前最常用的版本还是 HTTP 1.1）

## HTTP 2.0 和 HTTP 3.0 有什么区别

### 基于的协议不同

HTTP 2.0 基于 TCP 协议

HTTP 3.0 基于 **UDP 协议**，使用 QUIC 协议，提供类似 TCP 的可靠性和多路复用。

### HTTP 3 相比于 HTTP 2 的优势

1. 彻底解决队头阻塞问题，不会受到 TCP 队头阻塞的影响
2. HTTP/3 强制使用 QUIC 自带的 TLS 1.3 加密协议，安全性更高。
3. 不需要 TCP 连接的三报文握手和四报文挥手，连接建立和释放的代价更小。

## HTTP 和 HTTPS 的区别

HTTP 是明文传输信息，容易别窃听或篡改，不安全。

HTTPS 通过 SSL/TLS 协议加密传输信息，传输

## TCP 的三报文握手

TCP 通信的双方需要通过三次握手建立连接，然后才能真正进行通信。

1. 第一个握手报文：客户端向服务端发送请求建立连接的报文（同步位置1）
2. 第二个握手报文：服务端接收到请求建立连接报文后，向客户端发送一个响应报文，并且 SYN 置为1，表示同意建立连接。
3. 第三个握手报文：客户端收到服务端的响应报文后，会向服务端返回一个响应报文，表示连接成功建立。

### 为什么需要三次握手

1. **避免历史错误连接的建立**：由于网络问题客户端可能会发送多次请求建立连接报文，客户端通过发送握手响应报文可以告诉服务端哪些连接是无效的、旧的连接，哪些连接是正确的、有效的。
2. 帮助通信双方**初始化序列号**：第一次报文会携带一个随机的序列号。响应报文会返回对应的响应序列号，通过序列号可以保证消息的交换是有序的，不会受到无效报文的影响。

## TCP 的四次挥手

> TCP 连接断开需要四次挥手

第一次挥手：客户端向服务器发送释放连接的请求报文（FIN=1）

第二次挥手：服务端向客户端返回普通的响应报文，表示接收到请求，但可能还有一些数据没有传递完成，不会立即断开连接。

第三次挥手：服务器发送完数据后，向客户端发送响应报文确认连接释放（FIN=1）

第四次挥手：客户端向服务端发送响应报文，表示收到服务器断开连接的消息（客户端发送完报文后不会立即进入 closed 状态，而是会进入 time_wait 状态，以防响应报文丢失和确保旧报文全部失效）

### 为什么需要四次挥手

> 以下是个人理解

如果把中间两次挥手看成一次消息传递的话，那一共就只来回传递三次数据（和三次握手一样）

那为什么三次消息传递就能保证连接断开呢？我们都知道 TCP 是通过**确认重传**机制来保证消息的可靠性的，如果客户端想知道发送的消息服务器是否接收到，就必须接收到服务器的响应报文，这一来一回就是两次消息传递，服务器亦然。而服务器发送的响应报文既充当了客户端需要的响应报文，又可以看成服务器发送的同意连接释放报文，所以总共三次消息传递就可以确保连接释放或建立。

## TCP 的半包和粘包问题

半包问题：只收到部分报文

粘包问题：收到一个完整报文以上的字节序列

### 为什么 TCP 会出现半包和粘包问题

TCP 协议虽然是面向报文的协议，但是**按字节接收的**，不同报文之间没有明显界限。

### 如何解决半包粘包

1. 不同报文之间加分隔符
2. 报文长度固定
3. 报文首部长度固定并在首部设置**消息体的长度字段**，接收方通过这个长度字段来接收消息体。

## TCP 的拥塞控制

主要是通过**维护一个拥塞窗口的大小**实现的，涉及四个算法：慢开始、拥塞避免、快重传和快恢复

### 慢开始

发送方一开始发送数据时，由于不知道网络质量的好坏，会先发送少量数据，再以指数的方式扩大拥塞窗口（每收到一个响应报文就让拥塞窗口加1），直到窗口达到门限值。

### 拥塞避免

拥塞窗口达到门限值后，执行拥塞避免算法，拥塞窗口以线性方式增长。

### 快重传和快恢复

> 当发送方无法接收到响应报文时，会判断网络已经发生拥堵，将拥塞窗口的值置为0，门限值缩小到之前拥塞窗口的一半，然后执行慢开始算法。但在有些情况，可能只是部分发送的报文意外丢失了，所以接收不到响应，这时要执行快重传和快恢复算法。

**快重传**：当接收方发现有**个别报文出现丢失**时，会连续发送**同一个报文的重复确认报文**（3-ACK），发送方接收到之后会知道只是个别报文发生丢失，于是重传这些报文，这就是快重传。

**快恢复**：快重传之后，发送方会执行快恢复算法，将拥塞窗口和门限值都调整位之前拥塞窗口的一半，然后执行拥塞避免算法。

## IO 模型

### BIO

Blocking IO，即**阻塞型 IO**。在调用 IO 操作时，进程会被阻塞，直到操作系统将数据准备好，再将数据从内核空间拷贝到用户空间。

### NIO

Non-blocking IO，即**非阻塞 IO**。在调用 IO 接口时，会立即返回结果或者状态，进程不会被阻塞。

### IO多路复用

NIO 虽然不会阻塞进程，但是每个进程需要每隔一段时间询问操作系统数据是否准备好。IO 多路复用可以指定一**个进程去监听多个 IO 操作**，当任意一个操作就绪时进行处理。

（PS：需要使用`select`、`poll`或者`epoll`这样的系统调用）

### 信号驱动 IO

在数据准备好之后，内核通知进程进行 IO 操作，进程在接收到信号后进行数据的读入或写出。

### AIO

异步 IO，发送 IO 请求后立即返回，操作系统在后台完成 IO 操作，并且在操作完成之后通知进程，进程不需要等待 IO 结果就可以执行别的任务。

### 总结

1. BIO：从发送 IO 请求到拷贝数据都是进程做的，中间一直等待。
2. NIO：每隔一段时间查询 IO 请求的结果
3. IO 多路复用：专门指派一个线程去查询，而不是每个 NIO 线程都要去查询。
4. 信号驱动 IO：不用去查询，操作系统数据准备好告诉我。
5. AIO：只需要发送 IO 请求，剩下的工作全部交给 OS。

## Select、Poll 和 Epoll

都是实现 **IO 多路复用**的系统调用。

### Select

早期的 IO 多路复用机制，用**固定大小的位图**来表示文件描述集，每次`select`都需要重新构建和检查文件描述符集。

**缺点**：支持的文件描述符数量有限，在大规模连接的场景下效率较低。

### Poll

与 `select` 类似，区别是使用**动态数组**去存放文件描述符集，没有最大连接数限制，每次遍历仍然需要遍历全部描述符。

### Epoll

是 `Linux` 系统对 `select` 和 `poll` 的优化，提供了**边缘触发**和**水平触发**两种模式。

**不会遍历所有文件描述符**，而以事件通知的方式，只处理实际发生变化的描述符，适合**高并发**服务器。

## 为什么网络 IO 会被阻塞

网络 IO 会被阻塞是因为进行网络数据传输时，OS 会将进程**挂起**，直到j数据传输完才将进程恢复运行。

阻塞的原因：

1. 传统网络 API 都是**阻塞 API**，调用时如果条件不满足就会等待。

条件不满组的情况：

1. **数据没有准备好**：例如，在读取 socket 的数据时，如果 socket 没有数据，就会阻塞。

2. **系统的资源有限**：例如缓冲区满了，那就只能等待系统资源空闲

   