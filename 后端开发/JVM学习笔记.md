# JVM学习笔记

##  Java 应用常见问题

内存泄露问题

CPU占用率突然升高问题

大型Java应用程序的调优

## JVM是什么？

![image-20241206205204695](https://sheephappy-blog-picture.oss-cn-beijing.aliyuncs.com/20241231224314709.png)


JVM实质上是一个应用程序，负责将**Java字节码文件**读入内存。

## 为什么要有JVM？

### JVM的功能

1. **解释和运行** Java 字节码文件。
2. **管理内存**：分配内存和GC
3. **即时编译**，实时解释 Java 指令，对热点代码进行优化



## JVM 的组成

类加载器、运行时内存、执行引擎（及时编译器、解释器、垃圾回收）、本地接口（一些接近底层，使用 C++ 实现的接口）



## Java字节码文件的组成部分

基础信息、常量池、字段、方法、属性

### 基本信息

1. 魔术：最前面四个字节是`ca fe ba be`，用来校验该文件是否是字节码文件。
1. 主副版本号： JDK 1.2之后，副版本号 = 主版本号 - 44

![image-20241206213522884](https://sheephappy-blog-picture.oss-cn-beijing.aliyuncs.com/20241231224326649.png) 

### 常量池

#### 字段的值如何引用常量？

如果属性值是一个字符串，会先指向常量池的`String_info`，然后该常量指向值的字面值。

原因：有些字段的属性名可能和字符串常量相同，属性名会直接指向常量中的字面值，与值的指向区分。

### 方法

#### 常见字节码指令

`istore_1`：将操作数栈的数弹出放到 1 号位置

`iload_1`：将 1 号位置的局部变量复制一份到操作数栈

`iconst_1`：将常量 1 放入栈

`iadd`：将栈的两个数相加

#### 分析案例

``` Java
int i = 0;
i = i++;
```

请问最终 i 的值为多少？

答案：0 。

用字节码进行分析

![image-20241207193602946](https://sheephappy-blog-picture.oss-cn-beijing.aliyuncs.com/20241231224332322.png)  

#### javap -v 命令

用于反编译字节码文件，适合在命令行模式下查看字节码文件，在 Linux 系统下还可以用重定向符将内容输出到文件中。

ps. 如果 jar 包需要先使用 jar -xvf 命令解压



#### Arthas

1. 简介一个非常牛逼的 Java 应用诊断工具

2. 常用命令：
   - dashboard：查看 Java 运行的各种信息
   - dump：将字节码信息输出到一个文件上
   - **jad**：可以将一个类的字节码信息**反编译成源文件**

## 类的生命周期

![image-20241207223840836](https://sheephappy-blog-picture.oss-cn-beijing.aliyuncs.com/20241231224336684.png)

“家宴准备了西式菜”

### 加载阶段

1. **类加载器**根据类的全限定名通过**不同的渠道**以二进制的方式获取字节码信息。
2. 方法区有 `InstanceKlass`，堆区有`java.lang.Class`



### 连接阶段

1. 验证：校验字节码内容是否遵守《Java虚拟机规范》，检验字节码指令的语义是否正确
2. 准备：给静态变量开辟空间，赋初值，一般为 0，真正的赋值在初始化阶段。

​		- ps. 如果静态变量加上了 final 修饰，在本阶段就会赋值。

3. 解析：将常量池中的**符号引用**替换成指向**内存的直接引用**



### 初始化阶段

#### 做的事情

执行`clinit`的指令，执行**静态代码块**的内容，给**静态变量赋值**，执行流程与代码流程一致

#### 什么情况会触发类的初始化

1. 访问一个类的**静态变量**（不用 final 修饰）或**静态方法**。例如，执行 main 方法

2. **生成**该类的一个**实例**，例如：`Class.forName(xxx)`、`new 一个对象`

   ps. 一个类的初始化只执行一次

3. 子类的 clinit 调用前，会先调用父类的 clinit

​	ps. 直接访问父类的静态变量，不会触发子类的 clinit



## 类加载器

### 应用场景

1. 企业级应用：SPI 机制、类的热部署、Tomcat类的隔离
2. 面试题：什么是类的双亲委派机制，如何打破
3. 解决线上问题

### 类加载器的分类

1. 由 **Java 语言**实现的，都需要继承`ClassLoader`
2. 由 JVM 底层源码实现的（C、C++），一般无法获取。

### JDK8及以前的类加载器

#### BootstrapClassLoader

1. 作用：加载**核心类**，例如 java.lang.String。
2. 特点：使用 c++ 编写，一般无法修改。

	3. 使用：可以加上虚拟机参数使 启动类加载器 加载自定义的类，`-Xbootclasspath/a:jar包路径和包名`

#### ExtensionClassLoader

1. 作用：加载比较**通用的类**
2. 特点：JDK提供，使用 Java 编写，
3. 使用参数扩展：`-Djava.ext.dirs=jar包目录`

​	ps. 这种方法会覆盖掉原来的扩展类目录，所以需要加上原来的扩展类目录，通过`:`分割，加上自定义类的目录

#### AppClassLoader

1. 加载 classpath 下的类文件

#### 类的双亲委派机制

1. 作用：

   - 避免核心类被恶意代码替换
   - 避免类的重复加载

2. 实现方式：**自底向上查找**是否加载过，如果父加载器没有加载，将加载任务交给父加载器，如果父加载器加载过，直接返回这个类；再**由顶向下进行加载**，如果都没有加载过，启动类加载器尝试加载，如果该类不在加载目录，将该类的加载交给子类。

#### 如何打破类的双亲委派机制？

1. 方法：

   	- 自定义类加载器

    - 线程上下文类加载器：一般是应用程序类加载器。 ps. 我感觉没有打破双亲委派机制
    - Osgi框架的类加载器（了解）

2. 为什么要打破类的双亲委派机制

​	使用自定义类加载器可以实现**不同应用之间类的隔离**

3. 一些注意点：
   - 自定义加载器默认的父加载器是`AppClassLoader`
   - 两个自定义类加载器可以加载限定名相同的类，因为在 JVM 中，只有**类加载器和类全限定名都相同才是同一个类**。

4. jdbc案例：jdbc的驱动是由应用程序类加载器加载的。

![image-20241208210625836](https://sheephappy-blog-picture.oss-cn-beijing.aliyuncs.com/20241231224347862.png)
#### 使用 Arthas 实现热部署
1. 将字节码信息反编译为源文件：`jad --source-only <类的全限定名>  > 指定目录/文件名.java`
1. 得到该类的classloader的哈希值：`sc -d 类的全限定名`
2. 通过该类的 classloader 进行编译：`mc -c <类加载器的hashcode>  源文件 -d 输出目录`
2. 将编译后的字节码文件加载进内存：`retransform 目录/xxx.class`

### JDK8之后的类加载器

jdk9 引入了 module 的概念

#### 启动类加载器

使用 Java 编写

#### 平台类加载器

取代了扩展类加载器，继承 BuiltinClassLoader

##  运行时数据区域（JVM管理的内存）

分为**线程不共享**数据和**线程共享**数据

![image-20241209142206557](https://sheephappy-blog-picture.oss-cn-beijing.aliyuncs.com/20241231224350244.png)


### 程序计数器 pc

####栈

1. 每一个方法的调用使用一个**栈帧**保存

2. **栈帧的组成：局部变量表、操作数栈、帧数据**
3. 局部变量表：int 占一个槽，long 占两个槽
4. 操作数栈
   - 在编译器就可以计算出操作数**栈的最大深度**

5. 帧数据：包括动态链接、方法出口、异常表
6. 栈内存溢出：JVM 会创建一个默认大小的栈，一般 1M 左右

### 堆

堆内存是**空间最大**的一块区域。创建的对象都在堆上。

需要关注的三个值， used(已用)  total（已分配的堆内存大小） max（可以分配给堆的最大内存）

服务器部署时，建议将 -Xmx 和 -Xms 设置为相同的值，这样 total 就等于 max，不用扩容

### 方法区（元空间）

主要分别 **类的元信息 、运行时常量池 和 字符串常量池**



字符串常量池：存放字符串的字面值，字符串还可以存放在堆内存中

注意：字符串用`+`进行拼接时，如果两个**操作数是变量**，那么实际上是用`StringBuilder.append()`方法进行拼接，结果在**堆内存**。如果两个操作数是字符串字面值，结果在**字符串常量池**。



jdk7之后，静态变量是放在堆区的；jdk7及之前存放在方法区

### 直接内存

1. 背景：jdk1.4 引入了 NIO，使用了直接内存
2. 解决问题：在进行 IO 时，可以直接从直接内存读取数据，而不用将直接内存拷贝到堆内存。



## 垃圾自动回收

线程不共享内存不使用 gc，因为它们随着线程的消亡而消亡

### 方法区的回收

判断一个类可以被卸载，需要**同时满足三个条件**

- 该类的所有实例已被回收
- 加载该类的类加载器已被回收
- 该类对应的 java.lang.Class 对象没有在任何地方被引用



### 堆的回收

#### 引用计数法（不采用）

为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。

缺点：维护计数器影响系统性能；**循环引用导致内存泄露**

#### 可达性分析算法

1. 可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象

2. GC Root对象：
   - 线程对象，引用线程栈帧中的方法参数、局部变量等
   - java.lang.Class 对象，一般静态变量被它关联
   - 监视器对象，同步锁 synchronized 关键字持有的对象
   - 本地方法调用使用的全局对象

### 五种对象引用

1. 强引用：GC Root 的引用。
2. **软引用**：相对于强引用是一种较弱的引用关系，常用于**缓存**。**内存不足会将软引用的数据回收**。
   - 如何使用：`SoftReference`

3. 弱引用：`WeakReference`
   - 在垃圾回收的时候，不管内存够不够，弱引用的对象都会被回收
   - 主要在`ThreadLocal`使用

4. 虚引用：用于直接内存的回收
5. 终结器引用：

### 垃圾回收算法

算法的评价指标：堆使用效率、吞吐量、最大暂停时间

#### 标记清除算法

1. 标记存活的对象，删除未标记的对象

2. 缺点：

   - 内存碎片多
   - 分配空间慢

  #### 复制算法

将堆内存划分为两块区域，From 空间 和 To 空间

把存活的对象从 From 转移到 To 区域，然后将 From 和 To 的名字互换



#### 标记整理算法

1. 标记阶段
2. 整理阶段：将对象往内存的一侧移动



#### 分代垃圾回收算法

现在**最优秀的垃圾回收算法**

将内存区域划分为**年轻代区**和**老年代区**

年轻代区化为为 伊甸区 和 两个幸存者区（一个 From， 一个 To）

**算法描述**：先向伊甸区存放对象，此时 GC 是尝试将存活对象转移到 To 区，并且会记录对象的年龄。如果年龄达到阈值，则将对象转移到老年代区。若老年代区慢，先尝试 minor GC，如果成功，则将对象放入伊甸区，否则抛出内存溢出异常。



### 垃圾回收器

垃圾回收器必须成对使用（年轻代和老年代）

年轻代一般使用复制算法，老年代一般使用标记整理算法

#### Serial 回收器

单线程串行回收

适用于 cpu 资源匮乏的情况

#### ParNew 垃圾回收器和CMS

用户线程和垃圾回收线程可以一起执行

缺点：浮动垃圾、内存碎片

#### ps 和 po 垃圾回收器

Parallel Scavenge是 **jdk8 默认**的年轻代垃圾回收器

Parallel Old 是为 ps垃圾回收器设计的老年版本

可以手动设置最大暂停时间和吞吐量，最好不好设置最大堆内存，因为jvm会根据前面两个指标自动调整



#### G1垃圾回收器

jdk9之后默认的垃圾回收器，建议使用。

G1的堆被划分为等大的区域

回收过程：

![image-20241210214020980](https://sheephappy-blog-picture.oss-cn-beijing.aliyuncs.com/20241231224354287.png)





## 内存泄露

如果Java不再使用一个对象，而这个对象依然在GC Root的引用链上，这个对象就不会被垃圾回收器回收，该情况称之为内存泄露。内存泄露积累会导致出现内存溢出问题。

### 解决内存溢出的思路

发现、诊断、解决、验证

### arthas tunnel

1. 使用步骤
   - 项目引入 arthas 起步依赖，配置 tunnel 服务器的信息
   - 独立部署 tunnel 服务器



### 内存溢出的常见原因

#### 代码问题（内存泄露）

1. 创建新类时没有重写equals() 和 hashCode() 方法，还把它生成的对象放进了map，误以为两个内容一样的对象的哈希值相等。

2. 内部类引用外部类：非静态内部类默认持有外部类对象；匿名内部类在非静态方法中被创建，会持有调用者的对象。

   > 解决方法：**使用静态内部类**。

3. **ThreadLocal的错误使用**：线程池的线程往 ThreadLocal 存放东西没有 remove，出现内存泄漏。
4. String 的 intern 方法，放入常量池的字符串很难被回收，所以尽量不要将随机的字符串放在常量池。
5. **通过静态字段保存对象**：如果大量的数据在静态变量中被长期引用，数据就不会释放，如果这些数据不再使用，就会造成内存泄露。

6. 资源使用完没有关闭，这部分内存不一定会泄露，但是会导致 close 方法不被执行。

#### 并发请求问题

用户向 Java 应用发送请求时，**正常情况下**，Java 应用返回数据后，这部分数据就可以在内存中被释放掉。

但如果同时有**大量并发的请求**，**处理数据的时间很长，大量数据同时存在内存中**，就可能导致内存溢出。



## 诊断 - 内存快照

当堆内存溢出时，需要堆内存保存下来，形成内存快照

如果堆内存溢出时想要查看内存快照：需要添加虚拟机参数：`-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=路径名+ .hprof`

### 如何生成堆内存快照

1. jdk 自带的`jmap`
2. arthas 的命令

### 在服务器环境生成内存快照的分析报告

1. 下载 linux 环境的 mat
2. 执行命令：`./ParseHeapDump.sh 快照文件路径 org.eclipse.mat.api:suspects
 org.eclipse.mat.api:overview org.eclipse.mat.api:top_components`



## 修复内存溢出问题

1. 服务器出现 OOM 内存溢出时，生成内存快照
2. 使用 mat 分析内存快照，找到内存溢出的对象
3. 尝试在开发环境重现问题，分析代码中的问题
4. 修改代码
5. 测试并验证结果



## 大文件导出导致的内存溢出

1. 使用 poi 导出大文件很容易内存溢出
2. 解决方法：
   - 使用 hutool 的 BigWriter 导出文件
   - 使用 easyexcel 分批导出



## ThreadLocal 产生泄露

1. 必须将 ThreaLocal 的释放操作放在拦截器的 `AfterCompletion` 里面，保证程序在抛出异常时也能将 ThreadLocal 里的数据释放掉



## 在线定位问题

> 生成内存快照并分析能够准确地判断出问题产生的原因，但也有一些问题

问题1：生成内存快照时，会影响用户请求

问题2：通过 MAT 分析内存快照，至少要准备 1.5 - 2 倍大小的内存空间

> 这些问题可以使用在线定位问题解决

#### 在线定位问题的优点

对用户的影响很少

#### 缺点

不会形成完整的报告，较难定位问题

### 在线定位问题的常用工具

#### jmap 命令

1. `jmap -histo:live 进程号 > 目录/xxx.txt`

2. 分析文件中占用内存最大的对象
3. 使用 arthas 的 `stack` 命令去跟踪目标对象的生成过程

#### btrace

可以通过编写脚本的方式



## GC 调优

> GC 调优的目的主要是避免垃圾回收引起**程序的性能下降**

### GC 调优的核心指标

#### 吞吐量

1. 业务吞吐量
2. 垃圾回收吞吐量：`计算公式 = 业务执行时间 / (业务执行时间 + 垃圾回收时间)`

### 延迟

垃圾回收所造成的延迟时间

#### 内存使用量

Java 应用占用系统内存的最大值，在满足前两个指标的前提下，这个值越低越好

### 发现问题

1. jstat 命令：`jstat -gc 进程id 每次统计的间隔（毫秒） 统计次数`：提供垃圾回收的信息
2. visualvm 插件：Visual Tool 插件，实时监控 Java 进程的堆内存结构。
   - 适合开发使用
3. Prometheus + Grafana：企业常用的运维方案
4. **分析 GC 日志**：在 jdk8，添加虚拟机参数，`-XX:+PrintGCDetails -Xloggc:文件名`

     - GC viewer

     - **GC easy**：使用简单，功能强大，但使用有次数限制




### 持续 FULLGC

可能原因：元空间不足

后果：造成程序卡顿



### 如何解决 GC 问题

#### 1.优化基础 JVM 参数的设置

1. `-Xmx 和 -Xms`参数：最好设置成相同，避免因为堆内存扩容影响程序性能
2. `-XX:MaxMetaspaceSize=值 和 -XX:MetaspaceSize=值`：第二个参数不是元空间的初始容量，而是元空间多大会触发 FULLGC，一般不需要设置，否则会影响对象得回收。
3. `-Xss虚拟机栈大小`：默认 1M
4. 不建议手动设置得参数：
   - `-Xmn`：年轻代的大小
   - `-XX:SurvivorRatio`
   - `-XX:MaxTenuringThreadshould`：最大晋升阈值

5. JVM参数模板：

```
-Xms1g
-Xmx1g
-Xss256k
-XX:MaxMetaspaceSize=512m 
-XX:+DisableExplicitGC
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/opt/logs/my-service.hprof
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:文件路径
```

> JDK9 及之后gc日志输出参数修改为 -Xlog:gc*:file=文件名

#### 2.减少对象的产生

对象短时间大量的创建会触发 FULLGC

#### 3.更换垃圾回收器

1. ps 和 ps：吞吐量比较好
2. parNew CMS：最长停顿时间少
3. G1：jdk9 之后强烈建议使用，全方面领先

#### 4.优化垃圾回收器参数

> 这部分优化效果未必出色，仅当前面失败才考虑



## 生成没有 FULLGC 的内存快照

`jmap -dump:format=b,file=目录/xxx.hprof <Java进程号>`



## 性能优化

进程 cpu 占用率接近百分百、某个请求响应时间很长、没有线程响应请求，这些可以通过性能调优解决

### 线程转储 Thread Dump

1. `jstack 进程号 > xxx.tdump`
2. 可以将 tdump 文件交给 jstack.view 或者 FastThread 网站分析

### 查找 cpu 占用率高的线程

1. `top -c`：找到 cpu 占用率高的进程，获得进程 id
2. `top -Hp id`：可以得到 cpu 占用率高的线程

### 查找占用时间长的方法

1. arthas 的 trace 命令：`trace 类名 方法名`
	- --skipJDKmethod
	- #cost > 毫秒值
	- -n 条数

p.s. 监控完需要 stop，避免影响程序性能

2. arthas 的 watch 命令



### arthas 的 profile 命令

可以生成方法执行的火焰图



### 线程被耗尽的问题

检查是否发生了死锁：`jstack -l 进程号 > xxx.txt`
