# 操作系统

## 进程和线程的区别

**进程**是**资源分配的基本单位**，主要由程序和 PCB 构成，是早期操作系统为了**实现多道程序运行**而建立的概念，一个进程可以包含多个线程。

**线程**，又称为**轻量进程**，是 **CPU 调度的基本单位**，因为进程的控制和通信的开销较大，为了**进一步提高程序执行的并发度**，创建了线程这个概念，同一个进程中的线程共享进程的资源。

## 进程的通信方式

### 匿名管道

一种**单向通信方**式，用于**父子进程**进行通信。

### 命名管道

支持**无亲缘关系**的进程进行通信。

### 消息队列

一个进程将消息发送到消息队列，另一个进程按顺序接收

### 共享内存

两个进程通过一个**公共的内存缓冲区**进行通信，数据交换速度快，但需要注意进程同步问题。

### 信号量

用一个数字代表资源的数量，提供 P（消耗信号量） 和 V（释放信号量） 两种原子操作，用于**进程同步**。

### 信号

一种**异步的通信方式**，用来**通知**进程发生了某个**事件**，常用于进程之间发送中断或禁止命令。

### 套接字 Socket

允许**不同主机的进程进行通信**，是网络通信的基础，也可以用做单台主机上不同进程的通信，适合传输大量数据的情景。

### 文件

通过读写同一个文件实现通信。

## 进程调度的算法

### 先来先服务

见名知意，哪个进程先进入就绪队列，就调度哪个进程。

### 短作业优先

优先执行占用 **CPU 时间短**的进程，这样的好处是使所有进程的平均响应时间最短，坏处是占用 CPU 长的进程可能一直得不到执行，陷入饥饿

### 优先权调度

根据进程的**优先级**进行调度，优先级越高，越容易被执行。

### 时间片轮转

给每个进程分配一定的**时间片**，时间片到了就换下一个进程执行，好处是提高系统的响应时间，多用于分时系统。

### 高响应比优先

这是一种**综合了先来先服务和短作业优先**的方法

> 如果都看作优先权调度的话，先来先服务的优先权由等待时间决定，等待时间越长，优先权越高；短作业的优先权由执行时间决定，执行时间越短，优先权越高。

高响应比优先权调度通过计算每个进程的响应比来计算优先权，`响应比 = （执行时间 + 等待时间） / 执行时间`。

可以发现，如果两个进程等待时间相同，那么执行短的进程限制性，体现短作业优先的特点；如果两个进程的执行时间相同，那么等待时间长的进程先执行，体现出先来先服务的特点。

### 多级反馈队列优先权调度

有多个就绪队列，每个队列的优先权和调度算法不同，适用于更复杂的情况。

## 用户态和内核态

是操作系统给 CPU 设置的**两种运行模式**，不同模式下能够访问的资源和进行的操作是不同的。

### 用户态

**应用进程**一般运行在用户态，权限较低，不能访问硬件资源（例如寄存器）和系统资源，需要通过系统调用与内核进行通信，由内核代为执行敏感性操作，安全性较高。

### 内核态

是操作系统内核运行的模式，当执行**系统调用**或者**处理中断**时，CPU 运行在内核态，能够直接访问**硬件资源**和**执行特权操作**（如内存管理和进程调度）。

## Reactor 模型

反应堆模型，是一种**处理高并发 I/O 事件**的**设计模式**，适合应用在网络服务器的开发。它通过**事件驱动机制**和**非阻塞 I/O** 实现高并发连接的处理。

### 核心组件

1. 事件反应器（Reactor）：负责等待和分发事件，通常封装了一个多路复用器，在事件产生时将其分发给相应的处理器。
2. 事件处理器（Handler）：每一个事件处理器与一个具体的 IO 事件绑定，例如连接、读、写，内部封装了处理事件的逻辑。
3. Acceptor：负责接收连接，为每一个新的连接分配一个 Handler 进行后续的处理。

### 应用场景

非常适合 **IO 密集**的业务场景，例如聊天室的服务器开发。

**代码示例**（Netty）：

```java
public class ChatServer {

    public static void main(String[] args) throws Exception {
        // 服务器配置
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class)
             .childHandler(new ChannelInitializer<SocketChannel>() {
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ch.pipeline().addLast(new StringDecoder(), new StringEncoder(), new ChatServerHandler());
                 }
             })
             .option(ChannelOption.SO_BACKLOG, 128)
             .childOption(ChannelOption.SO_KEEPALIVE, true);

            // 启动服务器
            ChannelFuture f = b.bind(8080).sync();
            f.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}

public class ChatServerHandler extends SimpleChannelInboundHandler<String> {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {
        System.out.println("Received message: " + msg);
        // 广播消息给所有客户端
        for (Channel channel : ChatServerHandler.getAllChannels()) {
            channel.writeAndFlush(msg + "\n");
        }
    }
}

```

## 为什么要有虚拟内存

虚拟内存可以扩大内存的逻辑空间，同时也能给内存管理增加灵活性。

### 提高内存利用率

虚拟内存的空间大小一般远大于实际的内存空间，通过换出一些未被访问的页面，可以将更多的内存空间分配给运行的进程，提高内存利用率。

### 进程隔离

通过虚拟内存可以很容易实现不同进程的隔离

### 逻辑地址和物理地址解耦

现代编程语言分配给变量的都是逻辑地址，逻辑地址可以在程序运行时动态地绑定物理地址，比传统的静态地址绑定更加灵活。

## 常用 Linux 命令

### 文件和目录相关

1. 创建文件：touch
2. 删除文件或目录：rm
3. **修改文件：vi/vim**
4. **查看文件**：
   - cat：查看文件的完成内容
   - tail/head：查看头几行或者尾几行的内容。`tail -f `可以实时查看日志文件的变化。
   - more/less：分页查看文件内容，适合查看大文件，可以配合管道符使用。（PS：更推荐使用 less）
5. 移动（重命名）：mv
6. 复制：cp
7. 展示目录下的文件：ll
8. 打印当前目录：pwd
9. 切换目录：cd
10. 创建目录：mkdir

### 系统管理

1. 查看所有进程：ps -ef

2. 查看进程状态和资源使用情况：top

3. 杀死进程：kill -9 [pid]

4. 查看文件系统的磁盘使用情况：df

5. 统计目录或文件所占的磁盘空间：du

### 网络相关

1. 查看端口占用情况：`netstat -ano`或者 `ss`

2. 查看和配置网络接口信息：`ifconifg`或者`ip`

3. 启动、停止服务：`systemctl start/stop 服务名`

4. 发送 HTTP 请求或者下载文件：`curl`或者`wget`

### 权限管理

1. 修改文件或者目录权限：chmod
2. 修改文件的所有者：chown
3. 添加或者删除用户：useradd 或者 userdel
4. 修改用户密码：passwd

## 分页和分段

是内存管理的两种方式

### 分段

分段的目的主要是**方便程序员的使用**，例如将程序空间划分为程序段、数据段和堆栈段等，段的大小可以不同。

### 分页

分页的主要目的是**提高内存的利用率**，减少外部碎片，也是虚拟内存的基础。在分页内存管理中，逻辑地址被划分为等大的页面，物理地址被划为为同样大小的页框，每次按页分配内存，访存时先用页号去页表查找物理块号，转换为物理地址，再去访问实际的内存空间。

## 软中断和硬中断

两种中断方式，前者是软件实现，后者硬件实现。

### 软中断

通过软件实现，优先级低，但是灵活，比如可以动态地设置中断优先级。一般用在程序运行中获得操作系统的服务，如文件读写，进程调度等。

### 硬中断

通过硬件实现，优先级高，效率很高，缺点是写死在硬件里面，很难扩展。很多底层事件通过硬中断处理，比如除 0 异常，计算结果溢出这些。
